bot_token = "TOEKN"

import discord
import pygame
import asyncio
import datetime
import time
import threading
import random
import pickle
import os
import requests
import html
import os
os.system("title Vortex-Trivia")

pygame.init()
client = discord.Client()

class Assets:
    questionfont         = pygame.font.Font("Amiko-Bold.ttf", 65)
    answerfont           = pygame.font.Font("Amiko-Bold.ttf", 50)
    answerend            = pygame.image.load("AnswerEnd.png")
    answermiddle         = pygame.image.load("AnswerMiddle.png")
    fontcolor            = 50,50,60
    playersymbol         = pygame.image.load("PlayerSymbol.png")
    playerfont           = pygame.font.Font("Amiko-Bold.ttf", 70)
    correctanswerend     = pygame.image.load("CorrectAnswerEnd.png")
    correctanswermiddle  = pygame.image.load("CorrectAnswerMiddle.png")
    wronganswerend       = pygame.image.load("WrongAnswerEnd.png")
    wronganswermiddle    = pygame.image.load("WrongAnswerMiddle.png")
    answercountfont      = pygame.font.Font("Amiko-Bold.ttf", 50)

Assets.answerstart = pygame.transform.flip(Assets.answerend, True, False)
Assets.correctanswerstart = pygame.transform.flip(Assets.correctanswerend, True, False)
Assets.wronganswerstart = pygame.transform.flip(Assets.wronganswerend, True, False)



class Question(Assets):
    

    def __init__(self, question, answers, correct, questionnumber):
        self.question = question
        self.answers = answers
        self.correct = correct
        self.questionnumber = questionnumber
        self.messageID = "ID"
        self.reactions = {
                     u"1\u20e3": [],
                     u"2\u20e3": [],
                     u"3\u20e3": []
                    }
        self.savage = False
        self.brutal = False

    def renderQuestion(self):
        question = self.question.split()
        lines = []
        currentLine = ""
        wordcount = 0
        for i in question:
            wordcount += 1
            appended = False
            if len(currentLine)+len(i)+1 < 30:
                currentLine += i+" "
            else:
                appended = True
                lines.append(currentLine[:-1])
                currentLine = i+" "

            if wordcount == len(question) and ((lines and lines[-1][-len(i)+1:] != i) or not appended):
                lines.append(currentLine[:-1])
            

        print(lines)
        rendersize = 1090, 1355#1937, 1355
        surface = pygame.Surface(rendersize)
        surface.fill((255,255,255))

        for line in lines:
            render = self.questionfont.render(line, True, self.fontcolor)
            surface.blit(render, render.get_rect(center=(rendersize[0]/2, 500-40*len(lines)+80*lines.index(line))))
        
        for answer in range(3):
            height = 780+180*answer
            surface.blit(self.answerstart, (40, height))
            circlesize = self.answoo
            erstart.get_size()
            for i in range(rendersize[0]-80-circlesize[0]*2):
                surface.blit(self.answermiddle, (40+circlesize[0]+i, height))
            surface.blit(self.answerend, (rendersize[0]-40-circlesize[0], height))

            render = self.answerfont.render(self.answers[answer], True, self.fontcolor)
            surface.blit(render, render.get_rect(centery=height+circlesize[1]/2*1.05, left=100))

        playersymbol = surface.blit(self.playersymbol, (50,60))
        render = self.playerfont.render(str(len([x for x in currentGame["Players"] if currentGame["Players"][x]])), True, (206,206,216))
        surface.blit(render, render.get_rect(centery=playersymbol.centery, left=playersymbol.right+20))

        pygame.image.save(surface, "temp/Question%s.jpg"%self.questionnumber)



    def renderAnswer(self):
        question = self.question.split()
        lines = []
        currentLine = ""
        wordcount = 0
        for i in question:
            wordcount += 1
            appended = False
            if len(currentLine)+len(i)+1 < 30:
                currentLine += i+" "
            else:
                appended = True
                lines.append(currentLine[:-1])
                currentLine = i+" "

            if wordcount == len(question) and ((lines and lines[-1][-len(i)+1:] != i) or not appended):
                lines.append(currentLine[:-1])
            

        print(lines)
        rendersize = 1090, 1355
        surface = pygame.Surface(rendersize)
        surface.fill((255,255,255))

        for line in lines:
            render = self.questionfont.render(line, True, self.fontcolor)
            surface.blit(render, render.get_rect(center=(rendersize[0]/2, 500-40*len(lines)+80*lines.index(line))))

        playercount = sum([len(self.reactions[x]) for x in self.reactions])
        if playercount:
            percents = [len(self.reactions[x])/playercount for x in self.reactions]
        else:
            percents = 0,0,0

        if min(percents) == percents[self.correct-1] and percents.count(min(percents)) < 3:
            self.savage = True
            self.brutal = True

        if percents[self.correct-1] != max(percents):
            self.brutal = True


        for answer in range(3):
            height = 780+180*answer
            surface.blit(self.answerstart, (40, height))
            circlesize = self.answerstart.get_size()
            
            for i in range(rendersize[0]-80-circlesize[0]*2):
                surface.blit(self.answermiddle, (40+circlesize[0]+i, height))
            surface.blit(self.answerend, (rendersize[0]-40-circlesize[0], height))


            width = round((rendersize[0]-80-circlesize[0]*2)*percents[answer])
            if self.correct == answer+1:
                
                surface.blit(self.correctanswerstart, (40, height))
                circlesize = self.correctanswerstart.get_size()
                for i in range(width):
                    surface.blit(self.correctanswermiddle, (40+circlesize[0]+i, height))
                surface.blit(self.correctanswerend, (40+circlesize[0]+width, height))


            elif width:
                surface.blit(self.wronganswerstart, (40, height))
                circlesize = self.wronganswerstart.get_size()
                for i in range(width):
                    surface.blit(self.wronganswermiddle, (40+circlesize[0]+i, height))

                
            render = self.answerfont.render(self.answers[answer], True, self.fontcolor)
            surface.blit(render, render.get_rect(centery=height+circlesize[1]/2*1.05, left=100))

            render = self.answercountfont.render(str(len(self.reactions[list(self.reactions)[answer]])), True, (140,140,150))
            surface.blit(render, render.get_rect(centery=height+circlesize[1]/2*1.05, right=rendersize[0]-100))

        playersymbol = surface.blit(self.playersymbol, (50,60))
        render = self.playerfont.render(str(playercount), True, (206,206,216))
        surface.blit(render, render.get_rect(centery=playersymbol.centery, left=playersymbol.right+20))

        filename = "temp/QuestionAnswer%s.png"%self.questionnumber
        pygame.image.save(surface, filename)



try:
    savedata = pickle.load(open("savedata", "rb"))
except:
    savedata = {"Schedule": [{"Time": (22,46), "Prize": 200},
                             {"Time": (17,00), "Prize": 50}]
                }


currentGame = {"Question": None,
               "Players": {}
               }


@client.event
async def on_ready():
    print("Vortex-Trivia bot connected as "+client.user.name)
    voicechannel = client.get_channel("Voice Channel")
    #voicechannel = client.get_channel("471459845279842305") #testchannel
    textchannel = client.get_channel("Text Channel")
    #textchannel = client.get_channel("471459800274698240") #testchannel
    template = "**The next Vortex-Trivia Game starts in %s hour%s and %s minute%s! :clock1:**"
    
    while True:
        timemessage = await client.send_message(textchannel, "**The next Vortex Trivia Game starts in...**")
        for game in savedata["Schedule"]:
            gamedone = False
            while not gamedone:
                utcnow = datetime.datetime.now()#utcnow()
                print(utcnow)
                if utcnow.hour == game["Time"][0] and utcnow.minute == game["Time"][1]-2:
                    await client.delete_message(timemessage)
                    restart = True
                    restartcount = 0
                    while restart and restartcount < 2:
                        restart = False
                        questions = []
                        
                        diffis = {"easy": 8, "medium": 3, "hard": 1}
                        for diffi in ("easy", "medium", "hard"):
                            response = {"response_code": 1}
                            while response["response_code"]:
                                print("Getting...")
                                response = requests.get("https://opentdb.com/api.php?amount=%s&difficulty=%s&type=multiple"%(diffis[diffi], diffi)).json()
                                if [x for x in response["results"] if [y for y in x["incorrect_answers"]+[x["correct_answer"]] if len(y) > 30] or len(x["question"]) > 100]:
                                    response = {"response_code": 1}
                                
                            print(response)
                            difficulties = {'easy': 0, 'medium': 1, 'hard': 2}
                            for result in response["results"]:
                                result["difficulty"] = difficulties[result["difficulty"]]
                                result["question"] = html.unescape(result["question"])
                                result["correct_answer"] = html.unescape(result["correct_answer"])
                                result["incorrect_answers"] = [html.unescape(x) for x in result["incorrect_answers"]]
                            response["results"].sort(key=lambda x:x["difficulty"])

                            for result in response["results"]:
                                correct = random.randint(1,3)
                                answers = result["incorrect_answers"]
                                answers[correct-1] = result["correct_answer"]
                                question = [result["question"], answers, correct]
                                questions.append(question)

                        print(questions)
                        questions = [["What two numbers refer to very good eyesight?", ['24/7', '20/20', '34/85'], 2], ['Which "Star Wars" material shares its name with a real earthly substance?', ['Tibanna Gas', 'Carbonite', 'Coaxium'], 2]]
                        assert all(True for x in questions if len(x[1]) == 3 and type(x[2]) == int)

                        currentGame["Question"] = None
                        currentGame["Players"] = {}
                    
                        gamestate = await fakeQshow(game["Prize"], "Scott", questions, textchannel, voicechannel)
                        
                        if gamestate == "RESTART":
                            restart = True
                            restartcount += 1

                    gamedone = True
                    timemessage = await client.send_message(textchannel, "**The next Vortex Trivia Game starts in...**")
                            

                else:
                    nextgame = datetime.datetime(utcnow.year, utcnow.month, utcnow.day, game["Time"][0], game["Time"][1])
                    if game["Time"][0] < utcnow.hour:
                        nextgame += datetime.timedelta(days=1)
                    print(nextgame)
                    nextgame = nextgame-utcnow
                    print(nextgame)
                    nextgame = list(divmod(int(nextgame.seconds), 3600))
                    nextgame[1] = int(nextgame[1]/60)
                    print(nextgame)
                    await client.edit_message(timemessage, template%(nextgame[0], "s" if nextgame[0] != 1 else "", nextgame[1], "s" if nextgame[1] != 1 else ""))
                    await asyncio.sleep(60)




async def fakeQshow(prize, host, questions, textchannel, voicechannel):
    for x in client.voice_clients:
        if x.server == voicechannel.server:
            await x.disconnect()
            break
        
    open("gameIsLive", "w+")
    hostpath = "Hosts/"+host+"/"
    voice = await client.join_voice_channel(voicechannel)
    
    channel = textchannel

    waitingloop = random.choice(("Waiting Loop", "Waiting Oneshot", "Its My Time"))
    player = voice.create_ffmpeg_player("WaitingLoop/"+waitingloop+".mp3")
    #player = voice.create_ffmpeg_player("WaitingLoop/Welcome.mp3")
    message = await client.send_file(channel, open("WaitingLoop/%sPoints.gif"%prize, "rb"))
    player.start()
    nextshow = time.time()+246

    template = "**@Vortex The next Vortex Trivia Game starts in %02d:%02d!**"
    timeleft = nextshow-time.time()
    timemessage = await client.send_message(channel, template%divmod(int(timeleft-6), 60))
    while nextshow-time.time() > 6:
        timeleft = nextshow-time.time()
        await client.edit_message(timemessage, template%divmod(int(timeleft-6), 60))
        await asyncio.sleep(2)

    await client.delete_message(timemessage)
        
    await asyncio.sleep(nextshow-time.time())
    await client.delete_message(message)
    player.stop()
    

    
    questionnumber = 0
    brutalbefore = 0
    messagebefore = None
    for question, answers, correct in questions:
        print(answers, "Correct:", correct)
        questionnumber += 1
        if not brutalbefore or not [x for x in os.listdir(hostpath) if x.startswith("BrutalQuestion"+str(questionnumber-1)+"_")]:
            audiofile = [x for x in os.listdir(hostpath) if x.startswith("Question"+str(questionnumber)+"_")]
            if audiofile:
                audiofile = random.choice(audiofile)
                delay = float(audiofile.split("_")[-1][:-4])
                player = voice.create_ffmpeg_player(hostpath+audiofile)
            else:
                player = voice.create_ffmpeg_player('Question.mp3')
        else:
            audiofile = [x for x in os.listdir(hostpath) if x.startswith("BrutalQuestion"+str(questionnumber-1)+"_")]
            if audiofile:
                audiofile = random.choice(audiofile)
                delay = float(audiofile.split("_")[-1][:-4])
                player = voice.create_ffmpeg_player(hostpath+audiofile)
            else:
                await asyncio.sleep(3)
                player = voice.create_ffmpeg_player('Question.mp3')
                
        questionobj = Question(question, answers, correct, questionnumber)
        renderthread = threading.Thread(target=questionobj.renderQuestion)
        renderthread.start()
        while renderthread.isAlive():
            await asyncio.sleep(.25)

        if audiofile:
            player.start()
            if brutalbefore:
                brutalbefore = 0
                await asyncio.sleep(delay/2)
                await client.delete_message(messagebefore)
                await asyncio.sleep(delay/2-0.3)
            else:
                await asyncio.sleep(delay-0.3)
            message = await client.send_file(channel, open("temp/Question%s.jpg"%questionnumber, "rb"))
        else:
            if brutalbefore:
                brutalbefore = 0
                await client.delete_message(messagebefore)
            message = await client.send_file(channel, open("temp/Question%s.jpg"%questionnumber, "rb"))
            player.start()
        
        questionobj.messageID = message.id
        currentGame["Question"] = questionobj
        currentTime = time.time()
        emojis = (u"1\u20e3", u"2\u20e3", u"3\u20e3")
        for emoji in emojis:
            await client.add_reaction(message, emoji)
        await asyncio.sleep(10-(time.time()-currentTime))
        questionobj.messageID = "ID"
        await client.clear_reactions(message)
        currentTime = time.time()
        renderthread = threading.Thread(target=questionobj.renderAnswer)
        renderthread.start()
        while renderthread.isAlive():
            await asyncio.sleep(.25)
        
        await asyncio.sleep(5-(time.time()-currentTime))
        player.stop()
        
        audiofile = [x for x in os.listdir(hostpath) if x.startswith("Results"+str(questionnumber)+"_")]
        if audiofile:
            audiofile = random.choice(audi
